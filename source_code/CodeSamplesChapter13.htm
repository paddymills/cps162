<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Figure 12</title>
</head>

<body bgcolor="#FFFFCC">

<p align="center"><font face="Arial">Nyhoff, ADTs, Data Structures and Problem
Solving with C++, Second Edition,&nbsp;<br>
© 2005 Pearson Education, Inc. All rights reserved. 0-13-140909-3&nbsp;</font> </p>
<p align="center">&nbsp; </p>
<p align="center">&nbsp; </p>
<div align="center">
  <center>
  <table border="1" width="79%">
    <tr>
      <td width="100%">
        <h2 align="center"><font color="#FF0000"><a name="Figure 13.1">Figure
        13.1</a> Heap Algorithms in STL </font></h2>
      </td>
    </tr>
    <tr>
      <td width="100%">
        <pre><font color="#0000FF"><b>/**------------------------------------------------------------------------
   Demonstration of the heap algorithms in STL.
 ------------------------------------------------------------------------*/

#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;iomanip&gt;
#include &lt;algorithm&gt;
using namespace std;

template &lt;typename DataType&gt;
void displayTree(DataType x[], int n);

template &lt;typename DataType&gt;
void displayOneLevel(DataType x[], int numRows,
                     int row, int row_begin, int row_end);

int main()
{
   int x[11] = {87, 35, 74, 67, 79, 84, 76, 73, 81, 32};
   make_heap(x, x + 10);
   displayTree(x, 10);

   x[10] = 83;
   push_heap(x, x + 11);
   cout &lt;&lt; &quot;\nAfter push_heap(83):\n\n&quot;;
   displayTree(x, 11);

   pop_heap(x, x+11);
   cout &lt;&lt; &quot;\nAfter pop_heap( ):\n\n&quot;;
   displayTree(x, 10);

   sort_heap(x, x+10);
   cout &lt;&lt; &quot;\nAfter sort_heap( ), array contains:\n\n&quot;;
   for (int i = 0; i &lt; 10; i++)
      cout &lt;&lt; x[i] &lt;&lt; &quot;  &quot;;
   cout &lt;&lt; endl;
}

template &lt;typename DataType&gt;
void displayTree(DataType x[], int n)
/*------------------------------------------------------------------------
   Display a binary tree stored in an array in tree format.

   Precondition:  Binary tree is stored in an array x; n is the
       number of nodes in the tree .
   Postcondition: The binary tree has been displayed.
 ------------------------------------------------------------------------*/
{
   int beginIndex = 0,  // index of first node on some level
       endIndex = 0,    //    &quot;   &quot; last node on this level
       rowLength,       // length of current row
       numLevels = int(ceil(log(double(n)) / log(2.0)));  // Number of levels

   for (int level = 0; level &lt; numLevels; level++)
   {
      displayOneLevel(x, numLevels, level, beginIndex, endIndex);
      rowLength = endIndex - beginIndex + 1;
      beginIndex = endIndex + 1;
      endIndex = min(endIndex + 2*rowLength, n - 1);
   }
}

template &lt;typename DataType&gt;
void displayOneLevel(DataType x[], int numRows,
                 int level, int beginIndex, int endIndex)
/*------------------------------------------------------------------------
   Display nodes on one level of a binary tree stored in an array.

   Precondition:  Binary tree is stored in an array x; numRows is the
       number of rows used to display the entire tree, level is the 
       current level being displayed; and beginIndex and endIndex are 
       the indices in x of the first and last nodes on this level .
   Postcondition: Nodes on this level of binary tree have been 
       displayed.
 ------------------------------------------------------------------------*/
{
   int skip = int(pow(2.0, numRows - level) - 1);  
                                     // space between items in row
   for (int i = beginIndex; i &lt;= endIndex; i++)
   {
      cout &lt;&lt; setw(skip) &lt;&lt; &quot; &quot;;
      cout &lt;&lt; setw(2) &lt;&lt; x[i];
      cout &lt;&lt; setw(skip) &lt;&lt; &quot; &quot;;
   }
   cout &lt;&lt; &quot;\n\n&quot;;
}&nbsp;</b></font></pre>
      </td>
    </tr>
  </table>
  </center>
</div>

<p>&nbsp;</p>
<p align="center">&nbsp;</p>
<p align="center">&nbsp; </p>
<div align="center">
  <center>
  <table border="1" width="79%">
    <tr>
      <td width="100%">
        <h2 align="center"><font color="#FF0000"><a name="Split Template">Split
        Template</a></font></h2>
      </td>
    </tr>
    <tr>
      <td width="100%">
        <pre><font color="#0000FF"><b>template &lt;typename ElementType&gt;
void split (ElementType x[],
            int first, int last, int &amp; pos)
/*--------------------------------------------------------
   Rearrange x[first], ... , x[last] to position pivot.

   Precondition:   &lt; and == are defined for ElementType;
      first &lt;= pos &lt;= last.  Note that this version
      chooses pivot = x[first]; better pivot choices
      are described later in this section.
   Postcondition: Elements of sublist are rearranged and
      pos modified so x[first], ... , x[pos-1 &lt;= pivot
            and pivot &lt; x[pos + 1]\, ... , x[last].
----------------------------------------------------------*/
{
   ElementType pivot = x[first];    // pivot element
   int left = first,                // index for left search
       right = last;                // index for right search
   wile (left &lt; right)
   {
      while (pivot &lt; x[right])      // Search from right for
         right--;                   //    element &lt;= pivot
                                    // Search from left for
      while (left &lt; right &amp;&amp;        // element &gt; pivot
             (x[left] &lt; pivot || x[left] ==  pivot))
         left++;

      if (left &lt; right)             // If searches haven't met
         swap (x[left, x[right]);   //     interchange elements
   }
   // End of searches; place pivot in correct position
   pos = right;
   x[first] = x[pos];
   x[pos] = pivot;
}&nbsp;</b></font></pre>
      </td>
    </tr>
  </table>
  </center>
</div>

<p align="center">&nbsp;</p>
<p align="center">&nbsp; </p>
<div align="center">
  <center>
  <table border="1" width="79%">
    <tr>
      <td width="100%">
        <h2 align="center"><font color="#FF0000"><a name="Quicksort Recursive Function">Quicksort
        Recursive Function</a></font></h2>
      </td>
    </tr>
    <tr>
      <td width="100%">
        <pre><b><font color="#0000FF">template &lt;typename ElementType&gt;
void quicksort (ElementType x[], int first int last)
/*-------------------------------------------------------
   Quicksort array elements x[first], ..., x[last] so
   they are in ascending order.

   Precondition: &lt; and == are defined for ElementType.
      Note: Client programs call quicksort with first = 1
      and last = n - 1, where n is the list size
   Postcondition: x[first], ..., x[last] is sorted
---------------------------------------------------------*/
{
   int pos;                         // pivot's final position
   if (first &lt; last)                // list size is &gt; 1
   {
      split(x, first, last, pos);   // Split into 2 sublists
      quicksort(x, first, pos - 1); // Sort left sublist
      quicksort(x,pos + 1, last);   // Sort right sublist
   }
   // else list has 0 or 1 element and requires no sorting
}&nbsp;</font></b></pre>
      </td>
    </tr>
  </table>
  </center>
</div>

<p>&nbsp;</p>

</body>

</html>
